(let
    (
        (letrec (lambda (l) (let
            ((rec (lambda () (eval l))))
            (rec))))

        (fac (letrec '(lambda (n) (cond
            ((eq 1 n) 1)
            (t (* n ((rec) (- n 1)))) 
        ))))

        (map (letrec '(lambda (fn seq) (cond
            ((eq () seq) ())
            (t (cons (fn (car seq)) ((rec) fn (cdr seq))))
        ))))
    )
    (cons 
        (fac 5)
        (map (lambda (x) (* x 2)) '(1 2 3)))
) ===> (120 2 4 6) ; Amazingly, it actually worked!

((lambda () 3)) ==> 3
(- 1 2 MODULO) ==> 4294967295
(+ 1 2) ==> 3
(let ((nil '())) (cond (nil 1) (t 2))) ==> 2
(cond ('(()) 1) (t 2)) ==> 1
(cond ('() 1) (t 2)) ==> 2
(cond (() 1) (t 2)) ==> 2
(cond (t 1)) ==> 1
(cond ('t 1)) ==> 1
'(3 2 1)
(let ((AB 'T)) 'AB) ===> AB
(let ((AB 'T)) ('quote AB)) ===> T
't
(let ((AB (quote T))) ((quote quote) AB)) ===> T
(let ((AB (quote T))) (quote AB)) ===> AB
(cons (quote A) (quote B)) ===> (A B !)

(let
    (
        (y (quote C))
        (s (lambda (x) (lambda (y) (cons x y))))
        (sa (s (quote A)))
        (sb (s (quote B)))
        (sd (s (quote D)))
    )
    (sa 13)
)
