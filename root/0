(LET 
    (
        (nil (QUOTE ()))
        (true (QUOTE T))
        
        (not (LAMBDA (x)
            (COND
                ((EQ nil x) true)
                (true nil)
            )
        ))
        (and (LAMBDA (x y)
            (COND
                ((EQ nil x) nil)
                ((EQ nil y) nil)
                (true true)
            )
        ))
        (or (LAMBDA (x y)
            (COND
                ((EQ nil x) (and y true))
                (true true)
            )
        ))

        (cadr (LAMBDA (seq) (CAR (CDR seq))))
        (cddr (LAMBDA (seq) (CDR (CDR seq))))

        (pair CONS)
        (fst CAR)
        (snd CDR)

        (map (QUOTE (LAMBDA (fn seq)
            (COND
                ((EQ nil seq) nil)
                (true (CONS
                    (fn (CAR seq))
                    (map fn (CDR seq))
                ))
            )
        )))

        (foldl (QUOTE (LAMBDA (fn acc seq)
            (COND
                ((EQ nil seq) acc)
                (true (foldl fn (fn (CAR seq) acc) (CDR seq)))
            )
        )))

        (foldr (QUOTE (LAMBDA (fn acc seq)
            (COND
                ((EQ nil seq) acc)
                (true (fn (CAR seq) (foldr fn acc (CDR seq))))
            )
        )))

        (reverse (QUOTE (LAMBDA (seq)
            (foldl CONS nil seq)
        )))

        (scan-while (QUOTE (LAMBDA (cond body seq)
            (LET 
                (
                    (impl (QUOTE (LAMBDA (cond body seq acc)
                        (COND
                            ((EQ nil seq) (pair acc seq))
                            ((not (cond seq)) (pair acc seq))
                            (true (LET
                                (
                                    (res (body seq))
                                    (acc. (CONS (fst res) acc))
                                    (seq. (snd res))
                                )
                                (impl cond body seq. acc.)
                            ))
                        ))))
                    (res (impl cond body seq nil))
                )
                (pair (reverse (fst res)) (snd res))
            )
        )))
        
        (parse-mul (QUOTE (LAMBDA (seq)
            (COND
                ((ATOM (CAR seq)) (LET
                    (
                        (cond (QUOTE (LAMBDA (seq.)
                            (or
                                (EQ (QUOTE *) (CAR seq.))
                                (or 
                                    (EQ (QUOTE div) (CAR seq.))
                                    (EQ (QUOTE mod) (CAR seq.)))
                            ))))
                        (body (QUOTE (LAMBDA (seq.)
                            (COND
                                ((ATOM (cadr seq.)) (CONS (pair (CAR seq.) (cadr seq.)) (cddr seq)))
                            )
                        )))
                        (x (CAR seq))
                        (xs (scan-while cond body (CDR seq)))
                        (expr (QUOTE (LAMBDA (l r)
                            (CONS (fst l) (CONS r (CONS (snd l) nil)))
                        )))
                    )
                    (pair (foldl expr x (fst xs)) (snd xs))
                ))
            )
        )))

        (parse-sum (QUOTE (LAMBDA (seq)
            (COND
                ((ATOM (CAR seq)) (LET
                    (
                        (cond (QUOTE (LAMBDA (seq.)
                            (or
                                (EQ (QUOTE +) (CAR seq.))
                                (EQ (QUOTE -) (CAR seq.))
                            ))))
                        (body (QUOTE (LAMBDA (seq.)
                            (LET
                                ((mul. (parse-mul (CDR seq.))))
                                (CONS (pair (CAR seq.) (fst mul.)) (snd mul.))
                            )
                        )))
                        (x (parse-mul seq))
                        (xs (scan-while cond body (snd x)))
                        (expr (QUOTE (LAMBDA (l r)
                            (CONS (fst l) (CONS r (CONS (snd l) nil)))
                        )))
                    )
                    (pair (foldl expr (fst x) (fst xs)) (snd xs))
                ))
            )
        )))

    )
    (pair 12 13)
)
